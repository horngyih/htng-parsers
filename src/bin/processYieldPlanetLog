#! /usr/bin/env node
/* jshint esversion:6 */

const fs = require("fs");
const path = require("path");
const program = require("commander");
const xmljs = require("xml-js");
const moment = require("moment");

const {map,filter,take, partition} = require("rxjs/operators");

const messageTypes = require(path.join("..","messages","yieldplanet","messageTypes"));
const messageUtils = require(path.join("..","messages","messageUtils"));

const {lineStreamReader} = require(path.join("..","utils","lineReader"));
const {compact} = require(path.join("..","utils","compactor"));

const package = require(path.join("..","..","package.json"));

const messageFields = {
    "Common" : [
        "timestamp",
        "propertyCode",
        "ratePlan",
        "roomType",
        "startDate",
        "endDate"
    ],
    "SetRatePlan" : [
        "single",
        "doubleRate",
        "triple",
        "quad"
    ],
    "SetAvailabilityControl" : [
        "bookingLimit",
        "xFreesell",
        "xArrival",
        "xTA",
        "xOrg"
    ]
};

function dateParser(value){
    if( value ){
        return moment(value, "YYYY-MM-DD" );
    } else {
        return value;
    }
}

function dateTimeParser(value){
    if( value ) {
        return moment(value, "YYYY-MM-DD HH:mm:ss" );
    } else {
        return value;
    }
}

function bool(val){
    return val;
}

function mapMessageTypes( type ){
    let result = "SetAvailabilityControl";
    if( type ){
        if( type.match(/rate/i) ){
            result = "SetRatePlan";
        } else if( type.match(/avail/i) ){
            result = "SetAvailabilityControl";
        }
   }
    return result;
}

function prepareTimestampFilter(){
    let from = program.from;
    let to = program.to;
    if( from || to ){
        return filter(i=>{
          let onOrAfterFrom = (from)?i.timestamp.isSameOrAfter(from):true;
          let onOrBeforeTo = (to)?i.timestamp.isSameOrBefore(to):true;
          return onOrAfterFrom && onOrBeforeTo;
        });
    }
    return null;
}

function preparePropertyCodeFilter(){
    if( program.propertyCode ){
        let propertyCode= program.propertyCode;
        return filter(i=>{
            return i.propertyCode && i.propertyCode === propertyCode;
        });
    }
    return null;
}

function prepareRateCodeFilter(){
    if( program.rateCode ){
        let rateCode = program.rateCode;
        return filter(i=>{
            return i.ratePlan.toLowerCase() === rateCode.toLowerCase();
        });
    }
    return null;
}

function prepareRoomTypeFilter(){
    if( program.roomType ){
        let roomType = program.roomType;
        return filter(i=>{
            return i.roomType.toLowerCase() === roomType.toLowerCase();
        });
    } else {
        return null;
    }
}

function prepareStartEndDateFilter(){
    let start = program.startDate;
    let end = program.endDate;
    if( start || end ){
        return filter(i=>{
            let onOrAfterStart = (start)?i.startDate.isSameOrAfter(start):true;
            let onOrBeforeEnd = (end)?i.endDate.isSameOrBefore(end):true;
            return onOrAfterStart && onOrBeforeEnd;
        });
    }
    return null;
}


function prepareFilters(){
    let filterPipe = [];
    filterPipe.push(preparePropertyCodeFilter());
    filterPipe.push(prepareTimestampFilter());
    filterPipe.push(prepareRateCodeFilter());
    filterPipe.push(prepareRoomTypeFilter());
    filterPipe.push(prepareStartEndDateFilter());
    return filterPipe.filter(i=>i);
}

function getFields(){
    let fields = [].concat(messageFields.Common);
    fields = fields.concat(messageFields[program.message]);
    return fields;
 }

function printHeader(){
    console.log( getFields().join( program.delimiter || "|" ) );
}

function processLogs( files ){
    let targetFiles = [].concat(files);
    let filterPipe = prepareFilters();
    printHeader();
    files.forEach(
        file=>{
            processStream(fs.createReadStream(file));
       }
    );
}

function processStdin(){
    printHeader();
    processStream( process.stdin );
}

function processStream( stream ){
    let compacted = compact(lineStreamReader(stream),"INFO");
    messages = compacted.pipe( ...messageUtils.parseXMLPipe(messageTypes) );
    let partitioned = messages.pipe(
        partition(i=>i.messageType === "SetRatePlan")
    );

    if( program.mapping ){
        try{
            program.codeMapping = require(program.mapping);
        } catch(err){
            //Attempt to load current directory
            try{
                program.codeMapping = require(path.join(process.cwd(),program.mapping));
            }catch(err){
            }
        }
    }

    let targetStream = partitioned[1];
    switch( program.message ){
        case "SetRatePlan":
            targetStream = partitioned[0];
            break;
        case "SetAvailabilityControl":
            targetStream = partitioned[1];
            break;
    };

    if( targetStream ){
        targetStream 
            .pipe( ...prepareFilters() )
            .pipe( map(i=>{ 
                if( program.codeMapping ){
                    propertyMap = program.codeMapping[i.propertyCode];
                    if( propertyMap ){
                        let propertyMapping = { propertyCode : propertyMap.PROPERTY||i.propertyCode};
                        let roomMapping = { roomType : propertyMap.ROOM[i.roomType]||i.roomType };
                        let rateMapping = { ratePlan : propertyMap.RATEPLAN[i.ratePlan]||i.ratePlan };
                        return Object.assign({}, i, propertyMapping, roomMapping, rateMapping);
                    }
                }
               return i;
            } ) )
            .pipe( ...messageUtils.tabulateLine( messageTypes.SetMultipleOccupancyRates.formatters, getFields(), program.delimiter||"|" ) )
        .subscribe(console.log);
    }
 }

program
.version(package.version)
.usage("[options] <filename>")
.arguments("<filename...>")
.option("-o, --output <value>", "Output file")
.option("-d, --delimiter <value>", "Output delimiter")
.option("-p, --propertyCode <value>", "Filter by propertyCode" )
.option("--rateCode <value>", "Filter by Rate Plan Code" )
.option("--roomType <value>", "Filter by Room Type Code" )
.option("--startDate <value>", "Filter by Start Date (on or after start date)", dateParser )
.option("--endDate <value>", "Filter be End Date ( on or before end date)", dateParser )
.option("-m, --message <value>", "Filter for Message Type", mapMessageTypes, "SetAvailabilityControl" )
.option("-f, --from <value>", "Message sent after this timestamp", dateTimeParser )
.option("-t, --to <value>", "Message sent before this timestamp", dateTimeParser )
.option("--mapping <value>", "Mapping file" )
.option("--tail", "Process stdin" )
.action(
    (filename)=>{
        processLogs(filename);
})
.parse(process.argv);

if( program.args.length === 0 ){
    if( program.tail ){
        processStdin();
    } else {
        program.outputHelp();
    }
}
