#! /usr/bin/env node
/* jshint esversion:6 */

const fs = require("fs");
const path = require("path");
const program = require("commander");
const xmljs = require("xml-js");
const moment = require("moment");

const {from} = require("rxjs");
const {map,mergeAll,filter,take,partition,reduce} = require("rxjs/operators");

const messageTypes = require(path.join("..","messages","yieldplanet","messageTypes"));
const messageUtils = require(path.join("..","messages","messageUtils"));

const {lineStreamReader} = require(path.join("..","utils","lineReader"));
const {compact} = require(path.join("..","utils","compactor"));
const correlate = require(path.join("..","utils","correlator"));

const package = require(path.join("..","..","package.json"));

const idKey = /(?:ID:\s)(\d+)(?:\s)/; //Regular expression for extracting message IDs for correlation

//Message fields to be printed out in tabulation
const messageFields = {
    "Common" : [
        "timestamp",
        "propertyCode",
        "ratePlan",
        "roomType",
        "startDate",
        "endDate"
    ],
    "Correlated" : [
        "requestID",
        "unitID",
        "errorID",
        "status"
     ],
    "SetRatePlan" : [
        "single",
        "doubleRate",
        "triple",
        "quad"
    ],
    "SetAvailabilityControl" : [
        "bookingLimit",
        "xFreesell",
        "xArrival",
        "xTA",
        "xOrg"
    ]
};

//Parser for date type options
function dateParser(value){
    if( value ){
        return moment(value, "YYYY-MM-DD" );
    } else {
        return value;
    }
}

//Parser for datetime type options
function dateTimeParser(value){
    if( value ) {
        return moment(value, "YYYY-MM-DD HH:mm:ss" );
    } else {
        return value;
    }
}

//Parser for boolean type options
function bool(val){
    return val;
}

//Handler for message types 
function mapMessageTypes( type ){
    let result = "SetAvailabilityControl";
    if( type ){
        if( type.match(/rate/i) ){
            result = "SetRatePlan";
        } else if( type.match(/avail/i) ){
            result = "SetAvailabilityControl";
        }
   }
    return result;
}

//Returns a RXJS Filter function for Timestamp filtering
function prepareTimestampFilter(){
    let from = program.from;
    let to = program.to;
    if( from || to ){
        return filter(i=>{
          let onOrAfterFrom = (from)?i.timestamp.isSameOrAfter(from):true;
          let onOrBeforeTo = (to)?i.timestamp.isSameOrBefore(to):true;
          return onOrAfterFrom && onOrBeforeTo;
        });
    }
    return null;
}

//Returns a RXJS Filter function for Property Code filtering
function preparePropertyCodeFilter(){
    if( program.propertyCode ){
        let propertyCode= program.propertyCode;
        return filter(i=>{
            return i.propertyCode && i.propertyCode === propertyCode;
        });
    }
    return null;
}

//Returns a RXJS Filter function for RatePlan filtering
function prepareRateCodeFilter(){
    if( program.rateCode ){
        let rateCode = program.rateCode;
        return filter(i=>{
            return i.ratePlan.toLowerCase() === rateCode.toLowerCase();
        });
    }
    return null;
}

//Returns a RXJS Filter function for RoomType filtering
function prepareRoomTypeFilter(){
    if( program.roomType ){
        let roomType = program.roomType;
        return filter(i=>{
            return i.roomType.toLowerCase() === roomType.toLowerCase();
        });
    } else {
        return null;
    }
}

//Returns a RXJS Filter function for Start and End Date filtering
function prepareStartEndDateFilter(){
    let start = program.startDate;
    let end = program.endDate;
    if( start || end ){
        return filter(i=>{
            let onOrAfterStart = (start)?i.startDate.isSameOrAfter(start):true;
            let onOrBeforeEnd = (end)?i.endDate.isSameOrBefore(end):true;
            return onOrAfterStart && onOrBeforeEnd;
        });
    }
    return null;
}


//Read and prepare a sequence of filters for the parsed results
function prepareFilters(){
    let filterPipe = [];
    filterPipe.push(preparePropertyCodeFilter());
    filterPipe.push(prepareTimestampFilter());
    filterPipe.push(prepareRateCodeFilter());
    filterPipe.push(prepareRoomTypeFilter());
    filterPipe.push(prepareStartEndDateFilter());
    return filterPipe.filter(i=>i);
}

// Prepare the output fields requested for print out
function getFields(){
    let fields = [].concat(messageFields.Common);
    fields = fields.concat(messageFields[program.message]);
    if( program.correlate ){
        fields = fields.concat(messageFields.Correlated);
    }
    return fields;
 }

// Print the table header for the output fields request
function printHeader(){
    console.log( getFields().join( program.delimiter || "|" ) );
}

//Main Execution function -- process the files provided as a stream and output parsed results;
function processLogs( files ){
    let targetFiles = [].concat(files);
    let filterPipe = prepareFilters();
    printHeader();
    files.forEach(
        file=>{
            processStream(fs.createReadStream(file)).subscribe(console.log);
       }
    );
}

// Alternative Execution function -- process stdin stream as a stream and output the parsed results
function processStdin(){
    printHeader();
    processStream( process.stdin )
    .subscribe(console.log);
}

function correlateMessages(compacted){
    correlated = correlate(compacted, line=>(line.match(idKey)||["","noID"])[1], 2 );
    let messagePatterns = [/inbound/i, /outbound/i];
    let messages = correlated.pipe(
        map(group=>{
            return from(group).pipe( 
                ...messageUtils.parseXMLPipe(messageTypes), 
                reduce( (arr,message)=>(arr||[]).concat(message), [] ) 
            );
        }),
        mergeAll(),
        filter(i=>i&&i.length>0),
        map(i=>{
            if( Array.isArray(i) ){
                let messageByType = i.reduce( (map,message)=>{
                map = map || {};
                let messages = map[message.type]||[];
                messages.push(message);
                map[message.type]=messages;
                return map;
                }, {});
   
                let response = messageByType["SetMultipleOccupancyRatesResponse"][0];
                return from(
                    Object.keys(messageByType)
                        .filter(type=>type!=="SetMultipleOccupancyRatesResponse")
                        .reduce( (arr,type)=>{
                            return arr.concat(
                                messageByType[type]
                                    .map(i=>Object.assign(
                                        {}, 
                                        i, 
                                        {requestID:response.requestID}, 
                                        {status:(response.success)?"SUCCESS":"FAILED"},
                                        {errorID:response.errorID}
                                    )
                            ));
                        }, [])
                );
            } 
            return i;
        }),
        mergeAll()
    );
    return messages;
}

function parseMessages(compacted){
    return compacted.pipe(
        ...messageUtils.parseXMLPipe(messageTypes),
        filter(i=>i.type==="SetMultipleOccupancyRates")
    );
}

// Process the steam of lines read and parse them for Availability/RatePlan messages for output
function processStream( stream ){
    let compacted = compact(lineStreamReader(stream),"INFO");
    let messages = ( program.correlate )?correlateMessages(compacted):parseMessages(compacted);
    let partitioned = messages.pipe(
        partition(i=>i.messageType === "SetRatePlan")
    );

    if( program.mapping ){
        try{
            program.codeMapping = require(program.mapping);
        } catch(err){
            //Attempt to load current directory
            try{
                program.codeMapping = require(path.join(process.cwd(),program.mapping));
            }catch(err){
            }
        }
    }

    let targetStream = partitioned[1];
    switch( program.message ){
        case "SetRatePlan":
            targetStream = partitioned[0];
            break;
        case "SetAvailabilityControl":
            targetStream = partitioned[1];
            break;
    };

    if( targetStream ){
       return targetStream 
            .pipe( ...prepareFilters() )
            .pipe( map(i=>{ 
                if( program.codeMapping ){
                    propertyMap = program.codeMapping[i.propertyCode];
                    if( propertyMap ){
                        let propertyMapping = { propertyCode : propertyMap.PROPERTY||i.propertyCode};
                        let roomMapping = { roomType : propertyMap.ROOM[i.roomType]||i.roomType };
                        let rateMapping = { ratePlan : propertyMap.RATEPLAN[i.ratePlan]||i.ratePlan };
                        return Object.assign({}, i, propertyMapping, roomMapping, rateMapping);
                    }
                }
               return i;
            } ) )
            .pipe( ...messageUtils.tabulateLine( messageTypes.SetMultipleOccupancyRates.formatters, getFields(), program.delimiter||"|" ) )
    } else {
        return from([]);
    }
 }

program
.version(package.version)
.usage("[options] <filename>")
.arguments("<filename...>")
.option("-o, --output <value>", "Output file")
.option("-d, --delimiter <value>", "Output delimiter")
.option("-p, --propertyCode <value>", "Filter by propertyCode" )
.option("--rateCode <value>", "Filter by Rate Plan Code" )
.option("--roomType <value>", "Filter by Room Type Code" )
.option("--startDate <value>", "Filter by Start Date (on or after start date)", dateParser )
.option("--correlate", "Correlate messages" )
.option("--endDate <value>", "Filter be End Date ( on or before end date)", dateParser )
.option("-m, --message <value>", "Filter for Message Type", mapMessageTypes, "SetAvailabilityControl" )
.option("-f, --from <value>", "Message sent after this timestamp", dateTimeParser )
.option("-t, --to <value>", "Message sent before this timestamp", dateTimeParser )
.option("--mapping <value>", "Mapping file" )
.option("--tail", "Process stdin" )
.action(
    (filename)=>{
        processLogs(filename);
})
.parse(process.argv);

if( program.args.length === 0 ){
    if( program.tail ){
        processStdin();
    } else {
        program.outputHelp();
    }
}
